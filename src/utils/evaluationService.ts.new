/**
 * Add this to the top of the evaluationService.ts file
 * Import the keyword-based comparison service
 */

import { compareAnswers, compareMultipleAnswers, calculateTotalScore, AnswerComparisonResult } from './answerComparisonService';

/**
 * Evaluates a student's answer against a model answer using keyword matching
 * @param studentAnswer The student's answer text
 * @param modelAnswer The model answer text
 * @param questionText The question text
 * @param questionNumber The question number
 * @param totalMarks The total marks available for the question
 * @returns An evaluation result with score and feedback
 */
export const evaluateAnswer = async (
  studentAnswer: string,
  modelAnswer: string,
  questionText: string,
  questionNumber: number,
  totalMarks: number
): Promise<AnswerComparisonResult> => {
  console.log(`Evaluating answer for question ${questionNumber}:`);
  console.log(`Student answer: ${studentAnswer.substring(0, 100)}...`);
  console.log(`Model answer: ${modelAnswer.substring(0, 100)}...`);

  // Use the keyword-based comparison to evaluate the answer
  const result = compareAnswers(
    questionNumber,
    questionText,
    modelAnswer,
    studentAnswer,
    totalMarks
  );

  console.log(`Evaluation result for question ${questionNumber}:`, result);
  return result;
};

/**
 * Evaluates multiple student answers against model answers
 * @param studentAnswers Array of student answers
 * @param modelAnswers Array of model answers
 * @param questions Array of question objects with text and marks
 * @returns Array of evaluation results
 */
export const evaluateMultipleAnswers = async (
  studentAnswers: string[],
  modelAnswers: string[],
  questions: { number: number; text: string; marks: number }[]
): Promise<{
  results: AnswerComparisonResult[];
  totalScore: {
    totalMarksAwarded: number;
    totalMarksAvailable: number;
    percentage: number;
  };
}> => {
  console.log(`Evaluating ${studentAnswers.length} answers against ${modelAnswers.length} model answers`);

  // Use the keyword-based comparison to evaluate multiple answers
  const results = compareMultipleAnswers(
    questions,
    modelAnswers,
    studentAnswers
  );

  // Calculate the total score
  const totalScore = calculateTotalScore(results);

  console.log('Evaluation complete. Total score:', totalScore);
  return { results, totalScore };
};

/**
 * Extracts questions from question paper text
 * @param text The text of the question paper
 * @returns An array of question objects with text and marks
 */
export const extractQuestionsFromText = (text: string): { number: number; text: string; marks: number }[] => {
  console.log("Extracting questions from text:", text.substring(0, 100) + "...");

  // Split the text into lines
  const lines = text.split('\n').map(line => line.trim()).filter(line => line.length > 0);

  const questions: { number: number; text: string; marks: number }[] = [];
  let currentQuestionText = '';
  let currentQuestionNumber = 0;
  let currentMarks = 0;

  // Regular expressions for detecting question patterns
  const questionStartRegex = /^(?:Q|Question|Ques)\.?\s*(\d+)[.:]?\s*(.*)/i;
  const marksRegex = /\((\d+)\s*(?:marks|mark|points|point)\)/i;
  const standaloneNumberRegex = /^(\d+)[.:]?\s*(.*)/;

  for (let i = 0; i < lines.length; i++) {
    const line = lines[i];
    
    // Check if this line starts a new question
    const questionMatch = line.match(questionStartRegex) || line.match(standaloneNumberRegex);
    
    if (questionMatch) {
      // If we were already processing a question, save it
      if (currentQuestionNumber > 0 && currentQuestionText.length > 0) {
        questions.push({
          number: currentQuestionNumber,
          text: currentQuestionText.trim(),
          marks: currentMarks > 0 ? currentMarks : 5 // Default to 5 marks if not specified
        });
      }
      
      // Start a new question
      currentQuestionNumber = parseInt(questionMatch[1]);
      currentQuestionText = questionMatch[2] || '';
      
      // Check for marks in this line
      const marksMatch = line.match(marksRegex);
      currentMarks = marksMatch ? parseInt(marksMatch[1]) : 0;
    } else {
      // This line is part of the current question
      if (currentQuestionNumber > 0) {
        // Check if this line contains marks information
        const marksMatch = line.match(marksRegex);
        if (marksMatch && currentMarks === 0) {
          currentMarks = parseInt(marksMatch[1]);
        }
        
        // Add this line to the current question text
        currentQuestionText += ' ' + line;
      }
    }
  }
  
  // Add the last question if there is one
  if (currentQuestionNumber > 0 && currentQuestionText.length > 0) {
    questions.push({
      number: currentQuestionNumber,
      text: currentQuestionText.trim(),
      marks: currentMarks > 0 ? currentMarks : 5 // Default to 5 marks if not specified
    });
  }
  
  // If no questions were found, try a simpler approach
  if (questions.length === 0) {
    console.log("No questions found with standard format, trying simpler approach");
    
    // Split by double newlines to separate paragraphs
    const paragraphs = text.split(/\n\s*\n/).map(p => p.trim()).filter(p => p.length > 0);
    
    for (let i = 0; i < paragraphs.length; i++) {
      const paragraph = paragraphs[i];
      
      // Check if this paragraph looks like a question
      if (paragraph.includes('?') || /\b(explain|describe|discuss|define|what|how|why)\b/i.test(paragraph)) {
        questions.push({
          number: i + 1,
          text: paragraph,
          marks: 5 // Default to 5 marks
        });
      }
    }
  }
  
  console.log(`Extracted ${questions.length} questions:`, questions);
  return questions;
};
